#!/usr/bin/env perl
#
# lojban dictionary tool. obtain XML from http://jbovlaste.lojban.org
# and foist that into a sqlite database via `lefanva`
#
# TODO probably needs a rewrite as many new things have been bolted on
# over time

use 5.24.0;
use strictures 2;
use Data::Dumper;
use DBI;
use Getopt::Long qw(GetOptions);
use Term::ReadKey qw(GetTerminalSize);

my $DBFILE = "$ENV{HOME}/share/lojban/en.db";

my $Flag_Method           = 'LIKE';
my $Flag_SearchDefinition = 0;

Getopt::Long::Configure("bundling");
GetOptions(
    'definition|D' => sub { $Flag_Method = 'LIKE'; $Flag_SearchDefinition = 1 },
    'equal|eq|e'   => sub { $Flag_Method = '=' },
    'gismuify|g'   => \my $Flag_Gismu,
    'help|h|?'     => \&emit_help,
    'hify|H'       => \my $Flag_Hify,
    'like|l'       => sub { $Flag_Method = 'LIKE' },
    'recurse|R+'   => \my $Flag_Recurse,
    'selmaho|s=s'  => \my $Flag_Selmaho,
    'type|t=s'     => \my $Flag_Type,
) or exit 64;

emit_help() if $Flag_Selmaho and $Flag_Type;

$Flag_Recurse //= 0;

my $The_Word = shift // ( $Flag_Selmaho ? '%' : emit_help() );
my $lang     = shift // 'jbo';

my $Search_Field = 'word';
$Flag_Method = 'LIKE' if $The_Word =~ m/%/;

my $render_by;

if ( $lang eq 'en' ) {
    $render_by    = \&render_en;
    $Flag_Gismu   = 0;
    $Flag_Recurse = 0;
    undef $Flag_Selmaho;
    undef $Flag_Type;
} elsif ( $lang eq 'jbo' ) {
    $render_by = \&render_jbo;
    # treat "h" in input same as "'" as h is easier for me to type and
    # is more or less the same sound as what ' represents and other
    # lojban folks indicate they use this convention; use the hify flag
    # to try to mend ' to h in the output
    $The_Word =~ tr/h/'/ unless $Flag_SearchDefinition;
    $Search_Field = 'definition' if $Flag_SearchDefinition;
} else {
    die "mitysisku: unknown language |$lang| (use en|jbo)\n";
}

my @Lo_Valsi;
my $Words_Found = 0;

my $dbh = DBI->connect( 'dbi:SQLite:dbname=' . $DBFILE,
    '', '', { AutoCommit => 1, RaiseError => 1 } );

my $source = $dbh->quote_identifier($lang);

output_setup();

search( $The_Word, $Flag_Recurse ) unless $Flag_Gismu;

if ( $Words_Found == 0 and $lang eq 'jbo' and !$Flag_SearchDefinition ) {
    $Flag_Method  = '=';
    $Flag_Recurse = 0;

    # maybe a rafsi?
    if ( length $The_Word == 3 or $The_Word =~ m/^..'.$/ ) {
        my $gismu = gismu_or_cmavo($The_Word);
        search( $gismu, $Flag_Recurse ) if $gismu;
    } elsif ( length $The_Word > 4 ) {
        # lujvo must be at least six characters but need to support
        # exactly five if the user gave us a gismu here
        search( $_, $Flag_Recurse ) for decompose($The_Word);
    }
}

if ( $Words_Found == 1 and $lang eq 'en' ) {
    lineout();
    $lang        = 'jbo';
    $render_by   = \&render_jbo;
    $source      = $dbh->quote_identifier($lang);
    $Flag_Method = '=';
    search( $Lo_Valsi[0], 0 );
}

$dbh->disconnect;
undef $dbh;
emit();
exit $Words_Found == 0 ? 1 : 0;
END { $dbh->disconnect if $dbh }

sub bold { "\e[1m$_[0]\e[0m" }

sub decompose {
    my ($word) = @_;

    # NOTE this and subsequent CC are sloppy; there are restrictions on
    # consonant pairs CVCCV and more restrictions on leading consonant
    # pairs CCVCV
    my $gismu_re = qr{
      [bcdfgjklmnprstvxz][aeiou][bcdfgjklmnprstvxz][bcdfgjklmnprstvxz][aeiou] |
      [bcdfgjklmnprstvxz][bcdfgjklmnprstvxz][aeiou][bcdfgjklmnprstvxz][aeiou]
    }x;

    my @words;

    # maybe one or more short-form rafsi (CVC, CCV, CVV (and CVV may
    # appear as sa'i or sai)) or 4-letter rafsi (CCVC, CVCC e.g.
    # gismu) and these may be stuck together with one of [nry]. CVC
    # cannot appear in tail position (lujvo must end with a vowel)
    # TODO may need to add more cmavo forms
    my $prev_match = 0;
  LOOP: {
        # tail CCV, CVV, or a full gismu. however! cmevla can end with a
        # consonant, so must support parsing those as well; this adds
        # CVC and 4-letter rafsi forms as possible tails, I think
        if ($word =~ m{\G
           ($gismu_re |                                         # lujvo
            # cmevla
            [bcdfgjklmnprstvxz][bcdfgjklmnprstvxz][aeiou][bcdfgjklmnprstvxz] |
            [bcdfgjklmnprstvxz][aeiou][bcdfgjklmnprstvxz][bcdfgjklmnprstvxz] |
            [bcdfgjklmnprstvxz][bcdfgjklmnprstvxz][aeiou] |     # lujvo    
            [bcdfgjklmnprstvxz][aeiou]'?[aeiou] |               # lujvo
            [bcdfgjklmnprstvxz][aeiou][bcdfgjklmnprstvxz] )     # cmevla
            \z
        }cgx
        ) {
            maybe_push_rafsi( \@words, $1 );
            last LOOP;
        }

        # CVC may and CCVC, CVCC must have -y-
        if ($word =~ m{\G
           ([bcdfgjklmnprstvxz][bcdfgjklmnprstvxz][aeiou][bcdfgjklmnprstvxz] |
            [bcdfgjklmnprstvxz][aeiou][bcdfgjklmnprstvxz][bcdfgjklmnprstvxz] |
            [bcdfgjklmnprstvxz][aeiou][bcdfgjklmnprstvxz])
            y
            (?=[bcdfgjklmnprstvxz])
         }cgx
        ) {
            my $rafsi = $1;
            $prev_match += length($rafsi) + 1;
            maybe_push_rafsi( \@words, $rafsi );
            redo LOOP;
        }

        # CVV may have -r- or -n- to join it with next
        if ($word =~ m{\G
           ([bcdfgjklmnprstvxz][aeiou]'?[aeiou])        [rn]
           (?=[bcdfgjklmnprstvxz])
        }cgx
        ) {
            my $rafsi = $1;
            $prev_match += length($rafsi) + 1;
            maybe_push_rafsi( \@words, $rafsi );
            redo LOOP;
        }

        # CVC and CCV can be directly joined; with compound cmavo could
        # have CVV joined without the above [rn] thing
        if ($word =~ m{\G
           ([bcdfgjklmnprstvxz][aeiou][bcdfgjklmnprstvxz] |
           [bcdfgjklmnprstvxz][bcdfgjklmnprstvxz][aeiou]  |
           [bcdfgjklmnprstvxz][aeiou]'?[aeiou])
           (?=[bcdfgjklmnprstvxz])
        }cgx
        ) {
            my $rafsi = $1;
            $prev_match += length($rafsi);
            maybe_push_rafsi( \@words, $rafsi );
            redo LOOP;
        }

        die "mitysisku: unparsable input |$The_Word| (@words)\n",
          " " x ( pos // 0 + $prev_match + 29 ), "^\n";
    }

    die "no words parsed??" unless @words;
    return @words;
}

{
    my ( $cols, $rows, $output, $newlines );

    sub emit {
        if ( $newlines >= $rows and -t *STDOUT ) {
            my $pager = $ENV{PAGER} // 'more';
            open my $pipe, '|-', $pager or die "mitysisku: pager '$pager' failed: $!\n";
            print $pipe $output;
        } else {
            print $output;
        }
    }

    sub lineout {
        my $line = shift // "\n";
        $output .= $line;
        # plus seven as most of the long lines are tab prefixed and tabs
        # are usually eight characters wide when displayed
        $newlines += 1 + int( ( length($line) + 7 ) / $cols );
    }

    sub output_setup {
        ( $cols, $rows ) = GetTerminalSize(*STDOUT);
        $output   = '';
        $newlines = 1;
    }
}

sub emit_help {
    warn <<"END_USAGE";
Usage: mitysisku [options] word [en|jbo]

Lojban word lookup tool. Options include:

  -e    Use = for search (exact)
  -l    Use LIKE for search (default; %word% unless [%_] present)

  -g    Gismuify: only attempts to lookup gismu via rafsi of the
        input (this happens by default if nothing else in the
        dictionary matches).

  -R    Recurse; also looks up any related words. Repeat flag to
        increase the recursion depth. Recursion is disabled when
        performing a gismu search via rafsi (via -g or on no match).

  -t    Search for words of the given type (e.g. cmavo, ...)
  -s    Search by selmaho.

Piping to less(1) may require `less -R` due to the terminal escape
codes used.

END_USAGE
    exit 64;
}

sub gismu_or_cmavo {
    my ($word) = @_;
    if ( length $word == 5 ) {
        # gismu are five letters (and hopefully nothing else)
        return (
            $dbh->selectcol_arrayref( "SELECT word FROM jbo WHERE word = ?", {}, $word ) )
          ->[0];
    }
    my $found;
    if ( length $word == 4 and $word !~ m/'/ ) {
        # truncated gism aka 4-letter rafsi?
        $found = (
            $dbh->selectcol_arrayref(
                "SELECT word FROM jbo WHERE word LIKE ?",
                {}, $word . '_'
            )
        )->[0];
    } else {
        # assume a CCV, CVC or CVV form
        $found = (
            $dbh->selectcol_arrayref( "SELECT word FROM rafsi WHERE rafsi = ?", {}, $word )
        )->[0];
    }
    if ( !defined $found ) {
        # perhaps it's a cmavo?
        $found =
          ( $dbh->selectcol_arrayref( "SELECT word FROM jbo WHERE word = ?", {}, $word ) )
          ->[0];
    }
    return $found;
}

sub hify {
    my ($word) = @_;
    return $word unless $Flag_Hify;
    $word =~ tr/'/h/r;
}

sub maybe_push_rafsi {
    my ( $aref, $rafsi ) = @_;
    my $gismu = gismu_or_cmavo($rafsi);
    die "mitysisku: unknown rafsi |$rafsi| in |$The_Word|\n"
      unless defined $gismu;
    push $aref->@*, $gismu;
}

sub render_en {
    my ($row) = @_;

    push @Lo_Valsi, $row->{valsi};

    # include type so can e.g. easily identify gismu e.g. in a search
    # for 'return' found 'klakla' but missed the simpler 'xruti'
    $row->{type} = (
        $dbh->selectcol_arrayref(
            "SELECT type FROM jbo WHERE word=?",
            {}, $row->{valsi}
        )
    )->[0];

    $row->{sense} = $row->{sense} ? ' - ' . $row->{sense} : '';

    lineout($row->{word}
          . $row->{sense} . ' - '
          . bold( hify( $row->{valsi} ) ) . ' ('
          . $row->{type} . ')'
          . "\n" );

    return;
}

sub render_jbo {
    my ($row) = @_;

    my ( @gismu, $rafsi );
    if ( $row->{type} eq 'lujvo' ) {
        eval { @gismu = decompose( $row->{word} ) };
        $rafsi = [];
        for my $g (@gismu) {
            my $r = $dbh->selectcol_arrayref(
                "SELECT rafsi FROM rafsi WHERE word = ? ORDER BY rafsi",
                {}, $g );
            push @$rafsi, $r->@* ? $r->@* : '-';
        }
    } else {
        $rafsi =
          $dbh->selectcol_arrayref(
            "SELECT rafsi FROM rafsi WHERE word = ? ORDER BY rafsi",
            {}, $row->{word} );
    }

    lineout(bold( hify( $row->{word} ) ) . "\t("
          . $row->{type}
          . ( $row->{selmaho} ? ', ' . $row->{selmaho} : '' ) . ")"
          . ( @gismu ? ' ' . join ' ', map { bold($_) } @gismu : '' )
          . "\n" );

    lineout( "\t" . ( $row->{definition} // '(no definition provided)' ) . "\n" );

    $row->{rafsi} = join ' ', map { $_ eq '-' ? '-' : bold($_) } $rafsi->@*
      if $rafsi->@*;

    for my $field (qw/gloss rafsi notes/) {
        lineout( "\t" . uc($field) . " " . $row->{$field} . "\n" )
          if defined $row->{$field};
    }

    my $related =
      $dbh->selectcol_arrayref( "SELECT rel FROM rel WHERE word = ? ORDER BY rel",
        {}, $row->{word} );

    lineout(
        "\tRELAT " . join( ' ', map { bold( hify($_) ) } $related->@* ) . "\n" )
      if $related->@*;

    lineout();

    return $related;
}

sub search {
    my ( $word, $depth ) = @_;

    state %seen;
    $seen{$word}++;

    my $only = '';
    if ( defined $Flag_Type ) {
        my $meth = $Flag_Type =~ m/[%_]/ ? ' LIKE ' : ' = ';
        $only = 'type' . $meth . $dbh->quote($Flag_Type) . ' AND ';
    } elsif ( defined $Flag_Selmaho ) {
        # selma'o always uses LIKE so can type "bai" instead of "BAI"
        # and otherwise not have to match the awkward to type "upper
        # case, except for the h and a few other things" convention on
        # the word class names
        $only = 'selmaho LIKE ' . $dbh->quote($Flag_Selmaho) . ' AND ';
    }

    my $sth =
      $dbh->prepare(
        "SELECT * FROM $source WHERE $only $Search_Field $Flag_Method ? ORDER BY word");

    if ( $Flag_Method eq 'LIKE' and $word !~ m/[%_]/ ) {
        $word = '%' . $word . '%';
    }
    $sth->execute($word);

    my @more;
    while ( my $row = $sth->fetchrow_hashref ) {
        $Words_Found++;
        eval {
            my $related = $render_by->($row);
            if ( $depth > 0 and $related ) {
                for my $another ( $related->@* ) {
                    push @more, $another unless $seen{$another}++;
                }
            }
        };
        if ($@) {
            die "mitysisku: $@\n" . Data::Dumper->Dump( [$row], ['row'] );
        }
    }
    $depth--;
    search( $_, $depth ) for @more;
}
