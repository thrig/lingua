#!/usr/bin/env perl
#
# Lojban word lookup tool. Obtain XML dictionary from
# http://jbovlaste.lojban.org and first foist that into a sqlite
# database via lefanva.

use strictures 2;
use feature qw(say state);
use Data::Dumper;
use DBI;
use Getopt::Long qw(GetOptions);

# TWEAK
my $DBFILE = "$ENV{HOME}/share/lojban/en.db";

my $Flag_Method = 'LIKE';

Getopt::Long::Configure("bundling");
GetOptions(
    'equal|eq|e' => sub { $Flag_Method = '=' },
    'gismuify|g' => \my $Flag_Gismu,
    'help|h|?'   => \&emit_help,
    'hify|H'     => \my $Flag_Hify,
    'like|l'     => sub { $Flag_Method = 'LIKE' },
    'recurse|R+' => \my $Flag_Recurse,
    'regex|re'   => sub { $Flag_Method = 'REGEXP' },
) or exit 65;

emit_help() unless @ARGV;

$Flag_Recurse //= 0;

my $word = shift;
my $lang = shift // 'jbo';

my $render_by;

if ( $lang eq 'en' ) {
    $render_by = \&render_en;
} else {
    $render_by = \&render_jbo;

    # treat "h" in input same as "'" as h is easier for me to type and
    # is more or less the same sound as what ' represents and other
    # lojban folks indicate they use this convention; use the hify flag
    # to try to mend ' to h in the output.
    $word =~ tr/h/'/;
}

my $Words_Found = 0;

my $dbh = DBI->connect( "dbi:SQLite:dbname=$DBFILE", "", "",
    { AutoCommit => 0, RaiseError => 1, } );

if ( $Flag_Method eq 'LIKE' and $word !~ m/[%_]/ ) {
    $word = '%' . $word . '%';
}

my $source = $dbh->quote_identifier($lang);

search( $word, $Flag_Recurse ) unless $Flag_Gismu;

if ( $Words_Found == 0 and $lang eq 'jbo' ) {
    # maybe a rafsi?
    if ( length $word == 3 or $word =~ m/^..'.$/ ) {
        my $gismu = gismu_from_rafsi($word);
        search( $gismu, 0 ) if $gismu;
    }

    # maybe it's a lujvo? (e.g. 'dramau' not in my dictionary copy at
    # time of writing) TODO regex may need tweaks; TODO audit against
    # lujvo (esp. any irregular ones) extant
    if ( length $word > 4 ) {
        for my $frag (
            $word =~ m/(
            # five-letter gismu
            [bcdfgjklmnprstvxz][abcdefgijklmnoprstuvxz]{3}[aeiou]|
            # ..'. rafsi form
            [abcdefgijklmnoprstuvxz][abcdefgijklmnoprstuvxyz]'[abcdefgijklmnoprstuvxyz]|
            # ... rafsi
            [abcdefgijklmnoprstuvxz][abcdefgijklmnoprstuvxyz]{2})/gx
          ) {
            my $gismu = length $frag == 5 ? $frag : gismu_from_rafsi($frag);
            search( $gismu, 0 ) if $gismu;
        }
    }
}

$dbh->rollback;
$dbh->disconnect;
exit $Words_Found == 0 ? 1 : 0;

sub bold {
    my ($word) = @_;
    return "\e[1m" . $word . "\e[0m";
}

sub emit_help {
    warn <<"END_USAGE";
Usage: mitysisku [options] word [en|jbo]

Lojban word lookup tool. Options include:

  -e    Use = for search (exact)
  -l    Use LIKE for search (default; %word% unless [%_] present)
  -re   The 'word' is a REGEXP (slow)

  -g    Gismuify: only attempts to lookup gismu via rafsi of the input
        (this happens by default if nothing else in the dictionary
        matches). Compare:

          mitysisku ricyratcu
          mitysisku -g ricyratcu

  -R    Recurse; also looks up any related words (repeat flag to
        increase the recursion depth). Recursion is disabled when
        performing a gismu search via rafsi (via -g or on no match).

Piping to less(1) may require `less -R` due to the terminal escape
codes used.

END_USAGE
    exit 65;
}

sub gismu_from_rafsi {
    my ($word) = @_;
    my $gismu = (
        $dbh->selectcol_arrayref( "SELECT word from rafsi WHERE rafsi = ?", {}, $word )
    )->[0];
    return $gismu;
}

sub hify {
    my ($word) = @_;
    return $word unless $Flag_Hify;
    $word =~ tr/'/h/r;
}

sub render_en {
    my ($row) = @_;

    # include type so can e.g. easily identify gismu e.g. in a search
    # for 'return' found 'klakla' but missed the simpler 'xruti'
    $row->{type} = (
        $dbh->selectcol_arrayref(
            "SELECT type from jbo where word=? ",
            {}, $row->{valsi}
        )
    )->[0];

    $row->{sense} = $row->{sense} ? ' - ' . $row->{sense} : '';

    say $row->{word}, $row->{sense}, ' - ', bold( hify( $row->{valsi} ) ), ' (',
      $row->{type}, ')';

    return;
}

sub render_jbo {
    my ($row) = @_;

    say bold( hify( $row->{word} ) ) . "\t("
      . $row->{type} . ")\n\t"
      . ( $row->{definition} // '(no definition provided)' );

    my $rafsi =
      $dbh->selectcol_arrayref(
        "SELECT rafsi from rafsi WHERE word = ? ORDER BY rafsi",
        {}, $row->{word} );
    if (@$rafsi) {
        $row->{rafsi} = join ' ', map { bold($_) } @$rafsi;
    }

    for my $field (qw/gloss rafsi notes/) {
        say "\t" . uc($field) . " " . $row->{$field} if defined $row->{$field};
    }

    my $related =
      $dbh->selectcol_arrayref( "SELECT rel from rel WHERE word = ? ORDER BY rel",
        {}, $row->{word} );
    if (@$related) {
        say "\tRELAT ", join ' ', map { bold( hify($_) ) } @$related;
    }

    print "\n";

    return $related;
}

sub search {
    my ( $word, $depth ) = @_;

    state %seen;
    $seen{$word}++;

    my $sth =
      $dbh->prepare(
        "SELECT * from $source WHERE word $Flag_Method ? ORDER BY word");
    $sth->execute($word);

    my @more;
    while ( my $row = $sth->fetchrow_hashref ) {
        $Words_Found++;
        eval {
            my $related = $render_by->($row);
            if ( $depth > 0 and $related ) {
                for my $another (@$related) {
                    push @more, $another unless $seen{$another}++;
                }
            }
        };
        if ($@) {
            die "$@\n" . Data::Dumper->Dump( [$row], ['row'] );
        }
    }
    for my $another (@more) {
        search( $another, $depth - 1 );
    }
}
